<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matching Tiles Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha512-DxV+EoADOkOygM4IR9yXP8Sb2qwgidEmeqAEmDKIOfPRQZOWbXCzLC6vjbZyy0vPisbH2SyW27+ddLVCN+OMzQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"
        integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Tailwind CSS for a modern, clean look -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
     
        :root {
            --dark-blue: #0A1128;
            --light-blue: #00B4D8;
            --red: #D90429;
            --white: #F1F1F1;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--dark-blue);
            transition: background-color 0.5s ease;
        }

        /* New emergency border class */
        .emergency-border {
            border-color: var(--red);
            transition: border-color 0.5s ease;
        }

        /* Animations for success and failure */
        @keyframes match-animation {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes wrong-animation {
            0% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            50% {
                transform: translateX(5px);
            }

            75% {
                transform: translateX(-5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .tile-card-inner {
            animation: match-animation 0.5s ease-in-out;
        }

        .tile-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            animation: wrong-animation 0.5s ease-in-out;
        }

        .tile-card-inner {
            transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .tile-card {
            transform-style: preserve-3d;
        }

        .tile-card.is-flipped .tile-card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            border-radius: 0.5rem;
            backface-visibility: hidden;
        }

     .card-front {
    background-image: url("pics/istelogo.jpg");
    background-size: 60%;
    background-repeat: no-repeat;
    background-position: center;
    border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.card-front:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 18px rgba(0, 180, 216, 0.6); /* ISTE blue glow */
}
        .card-back {
            background: #1e40af;
       
            color: white;
            transform: rotateY(180deg);
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.5;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .heart-lost {
            animation: pulse 0.5s ease-in-out forwards;
        }


        .analog-timer {
            transform: rotate(-90deg);

        }

        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.8);
            }
        }

        .tile-card.fade-out {
            animation: fadeOut 0.6s forwards;
            pointer-events: none;
    
        }
    </style>
</head>

<body class="bg-gray-900 flex justify-center items-center min-h-screen text-white text-center transition-colors">

    <div
        class="container relative w-[95%] max-w-[600px] p-5 rounded-2xl shadow-xl bg-gray-800 bg-opacity-30 flex flex-col gap-5 border-2 border-blue-400">
        <!-- Start Screen -->
        <div id="game-start-screen"
            class="absolute inset-0 bg-gray-900 bg-opacity-95 z-20 flex flex-col justify-center items-center rounded-2xl transition-opacity duration-500">
            <h2 class="text-3xl sm:text-4xl font-bold mb-4">Memory Match</h2>
            <p class="text-lg sm:text-xl text-gray-300 mb-6">Can you find all the matching pairs?</p>
            <button id="start-btn"
                class="btn px-6 py-3 text-lg font-semibold rounded-lg shadow-md bg-blue-500 text-white hover:bg-blue-600 transition-colors transform hover:scale-105 active:scale-95">Play
                Game</button>
        </div>

       
        <div id="game-over-screen"
            class="absolute inset-0 bg-gray-900 bg-opacity-95 z-20 flex flex-col justify-center items-center rounded-2xl transition-opacity duration-500 opacity-0 pointer-events-none">
            <h2 id="game-over-title" class="text-3xl sm:text-4xl font-bold mb-4">Game Over!</h2>
            <p id="game-over-message" class="text-lg sm:text-xl text-gray-300 mb-6"></p>
            <button id="restart-btn"
                class="btn px-6 py-3 text-lg font-semibold rounded-lg shadow-md bg-blue-500 text-white hover:bg-blue-600 transition-colors transform hover:scale-105 active:scale-95">Play
                Again</button>
        </div>

  
        <div id="game-info"
            class="flex justify-between items-center h-16 p-3 rounded-lg bg-gray-700 bg-opacity-30 border border-blue-400">
            <div id="lives-container" class="flex gap-2 text-2xl text-red-500">
                <i class="fas fa-heart heart"></i>
                <i class="fas fa-heart heart"></i>
                <i class="fas fa-heart heart"></i>
            </div>
            <div class="flex items-center gap-3">
                <div id="analog-timer" class="w-10 h-10 rounded-full border-2 border-blue-400 relative"></div>
                <div id="timer-text" class="text-xl font-mono min-w-[50px] text-right">01:00</div>
            </div>
        </div>

        <div id="game-board"
            class="grid grid-cols-4 gap-3 p-3 rounded-lg min-h-[400px] border border-blue-400 bg-gray-700 bg-opacity-30">
        </div>

    
        <div id="message-box"
            class="fixed bottom-5 left-1/2 -translate-x-1/2 bg-gray-900 text-white py-2 px-4 rounded-md z-30 opacity-0 transition-opacity duration-500">
        </div>

    </div>

    <script>
        // Use window.onload to ensure the entire DOM is loaded before running the script
        window.onload = function () {
            const gameBoard = document.getElementById('game-board');
            const startScreen = document.getElementById('game-start-screen');
            const gameOverScreen = document.getElementById('game-over-screen');
            const startBtn = document.getElementById('start-btn');
            const restartBtn = document.getElementById('restart-btn');
            const livesContainer = document.getElementById('lives-container');
            const timerText = document.getElementById('timer-text');
            const analogTimer = document.getElementById('analog-timer');
            const messageBox = document.getElementById('message-box');
            const container = document.querySelector('.container');
            const gameInfo = document.getElementById('game-info');

            // Game state variables
            let lives = 3;
            let time = 60;
            let timerInterval;
            let isFlipping = false;
            let matchedPairs = 0;
            let firstCard = null;
            let secondCard = null;

       
            const emojis = [
                '<i class="fa-brands fa-node-js"></i>', '<i class="fa-brands fa-square-github"></i>', '<i class="fa-brands fa-square-facebook"></i>', '<i class="fa-brands fa-square-instagram"></i>', '<i class="fa-brands fa-square-x-twitter"></i>', '<i class="fa-brands fa-java"></i>', '<i class="fa-brands fa-python"></i>', '<i class="fa-brands fa-react"></i>'
            ];

            // Function to create and shuffle the tiles
            function createTiles() {
                // Duplicate the emojis to create pairs
                const tileEmojis = [...emojis, ...emojis];

              
                for (let i = tileEmojis.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [tileEmojis[i], tileEmojis[j]] = [tileEmojis[j], tileEmojis[i]];
                }

         
                tileEmojis.forEach(emoji => {
                    const card = document.createElement('div');
                    card.classList.add('tile-card', 'h-24', 'w-full', 'bg-blue-500', 'rounded-lg', 'flex', 'items-center', 'justify-center', 'text-4xl', 'cursor-pointer', 'shadow-md', 'transition-transform', 'duration-500');
                    card.dataset.emoji = emoji;

             
                    card.innerHTML = `
  <div class="tile-card-inner">
    <div class="card-face card-front" ></div>
    <div class="card-face card-back">${emoji}</div>
  </div>
`;

                    // Add click event listener to each card
                    card.addEventListener('click', handleTileClick);
                    if (gameBoard) {
                        gameBoard.appendChild(card);
                    }
                });
                $(".tile-card").css({
                    "font-family": "'Apple Color Emoji','Segoe UI Emoji','Noto Color Emoji',sans-serif"
                });
            }

            // Show a temporary message
            function showMessage(msg) {
                if (messageBox) {
                    messageBox.textContent = msg;
                    messageBox.classList.add('opacity-100');
                    setTimeout(() => {
                        messageBox.classList.remove('opacity-100');
                    }, 1500);
                }
            }

            // Handle a tile click event
            function handleTileClick(event) {
                const clickedCard = event.currentTarget;

                // Prevent flipping if two cards are already being checked or if the card is already flipped
                if (isFlipping || clickedCard.classList.contains('is-flipped')) {
                    return;
                }
                if (clickedCard === firstCard) return;

                // Flip the card and set it as the first or second card
                clickedCard.classList.add('is-flipped');
                if (!firstCard) {
                    firstCard = clickedCard;
                } else {
                    secondCard = clickedCard;
                    isFlipping = true;
                    setTimeout(checkForMatch, 800); 
                }
            }

         
            function checkForMatch() {
                if (!firstCard || !secondCard) return;

                const isMatch = firstCard.dataset.emoji === secondCard.dataset.emoji;

                if (isMatch) {
              
                    firstCard.classList.add('fade-out');
                    secondCard.classList.add('fade-out');

                    firstCard.removeEventListener('click', handleTileClick);
                    secondCard.removeEventListener('click', handleTileClick);

                    matchedPairs++;
                    showMessage('Match found!');

       
                    if (matchedPairs === emojis.length) {
                        clearInterval(timerInterval);
                        showGameOver('You win!');
                    }
                    firstCard = null;
                    secondCard = null;
                    isFlipping = false;
                } else {
                    firstCard.classList.add('wrong');
                    secondCard.classList.add('wrong');

                    setTimeout(() => {
                        firstCard.classList.remove('wrong', 'is-flipped');
                        secondCard.classList.remove('wrong', 'is-flipped');

                        firstCard = null;
                        secondCard = null;
                        isFlipping = false;
                    }, 800);

                    lives--;
                    updateLivesDisplay();
                    showMessage('Wrong!');

         

                }


                if (lives <= 0) {
                    clearInterval(timerInterval);
                    showGameOver('You lose!');
                }
            }

            // Update the lives display (heart icons)
            function updateLivesDisplay() {
                if (livesContainer) {
                    const hearts = livesContainer.querySelectorAll('.heart');
                    hearts.forEach((heart, index) => {
                        if (heart) {
                            if (index >= lives) {
                                heart.classList.add('heart-lost', 'text-gray-500');
                            } else {
                                heart.classList.remove('heart-lost', 'text-gray-500');
                            }
                        }
                    });
                }
            }

            // Update the timer display
            function updateTimerDisplay() {
                const seconds = time % 60;
                const minutes = Math.floor(time / 60);
                if (timerText) {
                    timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                // Update the analog timer visual
                const percentage = (time / 60) * 100;
                const timerColor = container && container.classList.contains('emergency-border') ? 'var(--red)' : 'var(--light-blue)';
                if (analogTimer) {
                    analogTimer.style.background = `conic-gradient(${timerColor} ${percentage}%, transparent ${percentage}%)`;
                }
            }

            // Countdown function
            function countdown() {
                time--;
                updateTimerDisplay();

                // Check for red border trigger
                if (time <= 15) {
                    if (container) container.classList.add('emergency-border');
                    if (gameInfo) gameInfo.classList.add('emergency-border');
                    if (gameBoard) gameBoard.classList.add('emergency-border');
                    if (analogTimer) analogTimer.classList.add('emergency-border');
                    if (timerText) timerText.classList.add('text-red-500');
                } else {
                    if (container) container.classList.remove('emergency-border');
                    if (gameInfo) gameInfo.classList.remove('emergency-border');
                    if (gameBoard) gameBoard.classList.remove('emergency-border');
                    if (analogTimer) analogTimer.classList.remove('emergency-border');
                    if (timerText) timerText.classList.remove('text-red-500');
                }

                // Check for game over
                if (time <= 0) {
                    clearInterval(timerInterval);
                    showGameOver('Time\'s up!');
                }
            }

            // Function to start the timer
            function startTimer() {
                clearInterval(timerInterval);
                timerInterval = setInterval(countdown, 1000);
            }

            // Display the game over screen
            function showGameOver(message) {
                if (gameOverScreen) {
                    gameOverScreen.classList.remove('opacity-0', 'pointer-events-none');
                }
                const gameOverMessage = document.getElementById('game-over-message');
                if (gameOverMessage) {
                    gameOverMessage.textContent = message;
                }
            }

            // Function to show all tiles for 3 seconds and then hide them
            function showAndHideTiles() {
                const tiles = document.querySelectorAll('.tile-card');

                // Flip all tiles open
                tiles.forEach(tile => tile.classList.add('is-flipped'));

              
                setTimeout(() => {
                    tiles.forEach(tile => tile.classList.remove('is-flipped'));
                    startTimer(); //
                }, 3000); // show for 3s
            }

          
            function startGame() {
                lives = 3;
                time = 60;
                isFlipping = false;
                matchedPairs = 0;
                firstCard = null;
                secondCard = null;

         
                if (gameBoard) {
                    gameBoard.innerHTML = '';
                }
                createTiles();

           
                if (startScreen) startScreen.classList.add('opacity-0', 'pointer-events-none');
                if (gameOverScreen) gameOverScreen.classList.add('opacity-0', 'pointer-events-none');

            
                if (container) container.classList.remove('emergency-border');
                if (gameInfo) gameInfo.classList.remove('emergency-border');
                if (gameBoard) gameBoard.classList.remove('emergency-border');
                if (analogTimer) analogTimer.classList.remove('emergency-border');
                if (timerText) timerText.classList.remove('text-red-500');

                updateLivesDisplay();
                updateTimerDisplay();

             
                showAndHideTiles();
            }

           
            if (startBtn) startBtn.addEventListener('click', startGame);
            if (restartBtn) restartBtn.addEventListener('click', startGame);

            updateLivesDisplay();
            updateTimerDisplay();
        }

    </script>
</body>

</html>